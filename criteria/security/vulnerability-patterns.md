# Vulnerability Patterns Reference Checklist

Canonical reference for identifying common vulnerability patterns in source code,
aligned with the OWASP Top 10 (2021 edition). Complements the inlined criteria in
`review-security.md`.

---

## A01: Broken Access Control

Failure to enforce proper authorization, allowing users to act outside their
intended permissions.

### Code Patterns to Detect

**Missing authorization checks**:
```python
# Python / Django - view without permission decorator
def admin_dashboard(request):
    return render(request, 'admin/dashboard.html')
# Should have: @login_required, @permission_required, or @user_passes_test
```

```javascript
// Node.js / Express - route without auth middleware
app.get('/api/admin/users', (req, res) => {
  return db.users.findAll();
});
// Should have: app.get('/api/admin/users', requireAuth, requireAdmin, handler)
```

```go
// Go - handler without auth check
func AdminHandler(w http.ResponseWriter, r *http.Request) {
    users, _ := db.GetAllUsers()
    json.NewEncoder(w).Encode(users)
}
// Should verify r.Context().Value("user").Role == "admin"
```

```java
// Java / Spring - endpoint without @PreAuthorize or @Secured
@GetMapping("/api/admin/users")
public List<User> getUsers() {
    return userRepository.findAll();
}
// Should have: @PreAuthorize("hasRole('ADMIN')")
```

**Insecure Direct Object Reference (IDOR)**:
```python
# User-supplied ID used directly without ownership check
@app.route('/api/documents/<doc_id>')
def get_document(doc_id):
    return Document.query.get(doc_id).to_json()
# Missing: verify document.owner_id == current_user.id
```

```javascript
// Direct use of user-supplied ID
app.get('/api/orders/:id', auth, (req, res) => {
  const order = await Order.findById(req.params.id);
  res.json(order);
});
// Missing: order.userId === req.user.id check
```

**Privilege escalation via parameter tampering**:
```regex
# Role or privilege set from user input
(?i)(role|is_admin|privilege|permission)\s*=\s*(req|request|params|body|query)
```

**Path traversal in access control**:
```regex
# File access using user input without validation
(?i)(open|read|write|send_file|serve|download)\s*\(.*\b(req|request|params)\b
```

### Severity: **CRITICAL** to **HIGH**

### Recommended Fix
- Enforce authorization at every endpoint via middleware or decorators.
- Validate resource ownership: always check that the requesting user owns or has
  permission to access the requested resource.
- Use indirect references (map user-facing IDs to internal IDs server-side).
- Default-deny: require explicit grants, not explicit denials.

---

## A02: Cryptographic Failures

Use of weak, broken, or improperly implemented cryptography.

### Code Patterns to Detect

**Weak hashing algorithms**:
```python
# Python
import hashlib
hashlib.md5(password.encode())      # Weak
hashlib.sha1(data.encode())         # Weak for passwords
```

```javascript
// Node.js
crypto.createHash('md5').update(password);   // Weak
crypto.createHash('sha1').update(password);  // Weak for passwords
```

```go
// Go
md5.Sum([]byte(password))     // Weak
sha1.Sum([]byte(password))    // Weak for passwords
```

```java
// Java
MessageDigest.getInstance("MD5");    // Weak
MessageDigest.getInstance("SHA-1");  // Weak for passwords
```

**Insecure random number generation**:
```python
import random
token = random.randint(0, 999999)   # Not cryptographically secure
# Use: secrets.token_hex(), secrets.token_urlsafe()
```

```javascript
Math.random()  // Not cryptographically secure
// Use: crypto.randomBytes(), crypto.randomUUID()
```

```go
math/rand  // Not cryptographically secure
// Use: crypto/rand
```

```java
new java.util.Random()  // Not cryptographically secure
// Use: java.security.SecureRandom
```

**Weak encryption**:
```regex
# DES, 3DES, RC4, Blowfish
(?i)(DES|DESede|RC4|RC2|Blowfish|ECB)
# ECB mode (any cipher)
(?i)\.MODE_ECB|/ECB/|AES/ECB
```

**Hardcoded initialization vectors or nonces**:
```regex
(?i)(iv|nonce|salt)\s*[:=]\s*["']?[A-Za-z0-9+/=]{8,}["']?
(?i)(iv|nonce|salt)\s*[:=]\s*b["'][^"']+["']
```

**Missing TLS verification**:
```python
verify=False                         # requests library
ssl._create_unverified_context()     # stdlib
```

```javascript
rejectUnauthorized: false            // Node.js TLS
NODE_TLS_REJECT_UNAUTHORIZED = "0"
```

```go
InsecureSkipVerify: true             // Go TLS config
```

```java
TrustAllCerts                        // Custom trust manager
X509TrustManager with empty methods
```

### Severity: **HIGH** to **CRITICAL**

### Recommended Fix
- Use bcrypt, scrypt, or Argon2 for password hashing.
- Use AES-256-GCM or ChaCha20-Poly1305 for symmetric encryption.
- Use cryptographically secure random generators for all security-sensitive values.
- Never disable TLS certificate verification in production.
- Generate unique IVs/nonces per encryption operation.

---

## A03: Injection

Untrusted data sent to an interpreter as part of a command or query.

### SQL Injection

```python
# Python - string formatting in queries
cursor.execute("SELECT * FROM users WHERE id = " + user_id)
cursor.execute(f"SELECT * FROM users WHERE name = '{name}'")
cursor.execute("SELECT * FROM users WHERE id = %s" % user_id)
# Fix: cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
```

```javascript
// Node.js - string concatenation in queries
db.query("SELECT * FROM users WHERE id = " + req.params.id);
db.query(`SELECT * FROM users WHERE name = '${req.body.name}'`);
// Fix: db.query("SELECT * FROM users WHERE id = $1", [req.params.id])
```

```go
// Go - fmt.Sprintf in queries
db.Query(fmt.Sprintf("SELECT * FROM users WHERE id = '%s'", userID))
// Fix: db.Query("SELECT * FROM users WHERE id = $1", userID)
```

```java
// Java - string concatenation in queries
stmt.executeQuery("SELECT * FROM users WHERE id = '" + userId + "'");
// Fix: PreparedStatement with parameterized query
```

**Detection regex**:
```regex
(?i)(execute|query|raw|exec)\s*\(\s*["'`]?\s*SELECT.*\+
(?i)(execute|query|raw|exec)\s*\(\s*f["']
(?i)(execute|query|raw|exec)\s*\(\s*["'`]?.*%[sd]
```

### Command Injection

```python
os.system("ping " + hostname)
subprocess.call("ls " + directory, shell=True)
# Fix: subprocess.run(["ping", hostname], shell=False)
```

```javascript
exec("ping " + hostname);
child_process.exec(`ls ${directory}`);
// Fix: child_process.execFile("ping", [hostname])
```

```go
exec.Command("sh", "-c", "ping " + hostname)
// Fix: exec.Command("ping", hostname)
```

```java
Runtime.getRuntime().exec("ping " + hostname);
// Fix: ProcessBuilder with argument list
```

**Detection regex**:
```regex
(?i)(os\.system|os\.popen|subprocess\.call|subprocess\.Popen|exec|execSync|child_process)\s*\(.*\+
(?i)shell\s*=\s*True
(?i)Runtime\.getRuntime\(\)\.exec\(.*\+
```

### Cross-Site Scripting (XSS)

```javascript
// DOM-based XSS
element.innerHTML = userInput;
document.write(userInput);
$(selector).html(userInput);

// Reflected XSS in server response
res.send("<h1>" + req.query.name + "</h1>");
```

```python
# Template injection / missing auto-escape
return HttpResponse(f"<h1>{user_input}</h1>")
# Jinja2 with autoescape disabled
{% autoescape false %}
{{ user_content }}
# Marking user content as safe
mark_safe(user_input)
```

**Detection regex**:
```regex
(?i)(innerHTML|outerHTML|document\.write|\.html\()\s*[=+(].*\b(req|request|params|query|user|input)
(?i)mark_safe\(
(?i)autoescape\s+(false|off|0)
(?i)\|\s*safe\b
(?i)dangerouslySetInnerHTML
```

### Server-Side Request Forgery (SSRF)

```python
requests.get(user_supplied_url)
urllib.request.urlopen(user_input)
```

```javascript
fetch(req.body.url);
axios.get(req.query.callback);
```

```go
http.Get(userURL)
```

```java
new URL(userInput).openConnection()
```

**Detection regex**:
```regex
(?i)(requests\.get|urllib|fetch|axios|http\.Get|HttpClient|openConnection)\s*\(.*\b(req|request|params|body|query|user|input)
```

### Path Traversal

```regex
# User input flows into file operations
(?i)(open|read|write|readFile|createReadStream|os\.path\.join)\s*\(.*\.\./
(?i)(open|read|write|readFile|createReadStream)\s*\(.*\b(req|request|params|query|body)
```

### Severity: **CRITICAL** (SQL injection, command injection) / **HIGH** (XSS, SSRF, path traversal)

### Recommended Fix
- **SQL**: Use parameterized queries or ORM-generated queries exclusively.
- **Command**: Avoid shell execution; use argument arrays. Validate input against allowlists.
- **XSS**: Use context-aware output encoding. Enable auto-escaping in templates.
- **SSRF**: Validate and allowlist target URLs/domains. Block internal IP ranges.
- **Path traversal**: Use `os.path.realpath()` or equivalent and verify the resolved
  path is within the expected base directory.

---

## A04: Insecure Design

Fundamental design flaws that cannot be fixed by implementation alone.

### Code Patterns to Detect

**Missing rate limiting on sensitive operations**:
```regex
# Login, password reset, OTP verification without rate limiting
(?i)(login|authenticate|reset_password|verify_otp|verify_code|forgot_password)
# Check: is there rate limiting middleware or logic wrapping these?
```

**Business logic bypass potential**:
```regex
# Price, quantity, or discount set from user input without validation
(?i)(price|amount|total|discount|quantity)\s*=\s*(req|request|params|body)
# Negative quantity, negative price, overflow
```

**Missing account lockout**:
```regex
# Authentication handlers without failed attempt tracking
(?i)def\s+(login|authenticate|sign_in)
# Verify: failed_attempts counter, lockout logic present
```

**Trust boundary violations**:
```regex
# Client-side validation only (no server-side counterpart)
# Server-side functions that trust client-provided role/permission claims
(?i)(is_admin|role|permission|authorized)\s*=\s*(req|request|body|params|cookie|header)
```

### Severity: **HIGH** to **MEDIUM**

### Recommended Fix
- Implement rate limiting on authentication, password reset, and other sensitive flows.
- Validate all business-critical values server-side.
- Design with threat modeling: identify trust boundaries and enforce them.
- Implement account lockout with progressive delays.
- Never trust client-side validation as the sole control.

---

## A05: Security Misconfiguration

Insecure default configurations, unnecessary features enabled, or missing hardening.

### Code Patterns to Detect

**Debug mode in production**:
```python
# Django
DEBUG = True
# Flask
app.run(debug=True)
app.config['DEBUG'] = True
```

```javascript
// Express
app.set('env', 'development');
// Verbose error details sent to client
app.use((err, req, res, next) => {
  res.status(500).json({ error: err.stack });
});
```

```go
// Gin
gin.SetMode(gin.DebugMode)
```

```java
// Spring Boot
server.error.include-stacktrace=always
spring.profiles.active=dev  // in production deployment
```

**Detection regex**:
```regex
(?i)DEBUG\s*=\s*True
(?i)debug\s*[:=]\s*(true|1|"true"|'true')
(?i)err\.(stack|message|trace)
(?i)include.stacktrace\s*=\s*always
```

**Permissive CORS**:
```regex
(?i)Access-Control-Allow-Origin\s*[:=]\s*["']?\*["']?
(?i)cors\(\s*\)           # Default CORS (often allows all)
(?i)allow_origins\s*[:=]\s*\[?\s*["']\*["']
```

**Default credentials or accounts**:
```regex
(?i)(admin|root|default|test):(admin|root|password|123456|default)
(?i)(username|user)\s*[:=]\s*["']?(admin|root)["']?.*\n.*(?i)(password|pass)\s*[:=]\s*["']?(admin|root|password)["']?
```

**Unnecessary services or endpoints**:
```regex
# Debug endpoints, health checks exposing internals
(?i)(debug|phpinfo|elmah|trace|server-status|\.env)
# Swagger/OpenAPI exposed without auth
(?i)(swagger|api-docs|openapi).*(?i)(public|no.?auth)
```

### Severity: **HIGH** (debug mode, permissive CORS) / **MEDIUM** (default configs)

### Recommended Fix
- Disable debug mode, verbose errors, and stack traces in production.
- Configure CORS with explicit allowed origins.
- Remove default accounts and credentials before deployment.
- Disable unnecessary endpoints, services, and features.
- Automate configuration validation in CI/CD pipelines.

---

## A06: Vulnerable and Outdated Components

Use of libraries, frameworks, or dependencies with known vulnerabilities.

### Code Patterns to Detect

**Dependency files to audit**:
```
# JavaScript/TypeScript
package.json, package-lock.json, yarn.lock, pnpm-lock.yaml

# Python
requirements.txt, Pipfile, Pipfile.lock, pyproject.toml, poetry.lock, setup.py

# Go
go.mod, go.sum

# Java
pom.xml, build.gradle, build.gradle.kts, gradle.lockfile

# Ruby
Gemfile, Gemfile.lock

# Rust
Cargo.toml, Cargo.lock

# .NET
*.csproj, packages.config, Directory.Packages.props
```

**Indicators of outdated or vulnerable components**:
```regex
# Pinned to very old versions
(?i)"version":\s*"[01]\.\d+\.\d+"

# Unpinned dependencies (wildcard, latest)
(?i)["']\*["']
(?i)["']latest["']

# Known vulnerable package names (examples - use advisory databases for current list)
# Check against: NVD, GitHub Advisory Database, Snyk DB, OSV
```

**Missing lockfiles**: If `package.json` exists but `package-lock.json` does not,
or `Pipfile` exists but `Pipfile.lock` does not, flag for non-reproducible builds.

**Vendored code without update mechanism**:
```
vendor/, third_party/, lib/external/
```
Check commit dates and version markers in vendored directories.

### Severity: **CRITICAL** (known exploited CVE) / **HIGH** (known CVE) / **MEDIUM** (outdated, unmaintained)

### Recommended Fix
- Run `npm audit`, `pip-audit`, `govulncheck`, `mvn dependency-check:check`, or
  equivalent for the ecosystem.
- Pin dependencies to specific versions with lockfiles.
- Automate dependency updates (Dependabot, Renovate).
- Monitor advisories: NVD, GitHub Security Advisories, OSV.dev.
- Establish a policy for maximum age of dependencies without update review.

---

## A07: Identification and Authentication Failures

Weak authentication mechanisms, credential stuffing exposure, session management flaws.

### Code Patterns to Detect

**Weak password policy**:
```regex
(?i)min.?(length|len|size)\s*[:=<]\s*[1-7]\b
(?i)password.?(min|length)\s*[:=]\s*[1-7]\b
# Missing: complexity requirements, breach database check
```

**Insecure session management**:
```python
# Flask - permanent session without timeout
session.permanent = True
# Missing: session timeout, rotation on privilege change
```

```javascript
// Express session without secure settings
session({
  secret: 'keyboard cat',        // Weak secret
  cookie: { secure: false }      // Not HTTPS-only
});
```

```regex
# Missing HttpOnly, Secure, SameSite on session cookies
(?i)httponly\s*[:=]\s*(false|0)
(?i)secure\s*[:=]\s*(false|0)
(?i)samesite\s*[:=]\s*["']?none["']?
```

**Credential exposure in logs**:
```regex
(?i)(log|logger|console|print|fmt\.Print)\s*\(.*\b(password|token|secret|credential|api_key)
```

**Missing multi-factor authentication hooks**:
```regex
# Login flow without MFA step
# Look for: login/authenticate functions that return success after password alone
# No reference to: totp, mfa, two_factor, 2fa, otp
```

**Plaintext password storage**:
```regex
(?i)(password|passwd)\s*=\s*(req|request|params|body)\.[^\n]*\n[^}]*save|insert|update|store
# Verify: is hashing applied before storage?
```

### Severity: **CRITICAL** (plaintext password storage, missing auth) / **HIGH** (weak session, no MFA)

### Recommended Fix
- Enforce minimum password length of 12+ characters; check against breached password databases.
- Use bcrypt/scrypt/Argon2 for password storage.
- Set session cookies with `Secure`, `HttpOnly`, `SameSite=Lax` (or `Strict`).
- Rotate session IDs after login and privilege changes.
- Implement MFA for sensitive operations.
- Never log credentials or tokens.

---

## A08: Software and Data Integrity Failures

Insecure deserialization, unsigned code/updates, CI/CD pipeline integrity issues.

### Code Patterns to Detect

**Insecure deserialization**:
```python
# Python - pickle from untrusted source
pickle.loads(user_data)
pickle.load(request.files['data'])
yaml.load(data)                      # Without Loader=SafeLoader
yaml.load(data, Loader=yaml.FullLoader)  # Still unsafe in some versions
# Fix: yaml.safe_load(data)
```

```javascript
// Node.js - eval-based deserialization
eval(userInput);
new Function(userInput);
node-serialize (any usage)
// JSON.parse is generally safe, but check what happens with the result
```

```java
// Java - ObjectInputStream from untrusted source
ObjectInputStream ois = new ObjectInputStream(untrustedStream);
Object obj = ois.readObject();
// XMLDecoder, XStream, Kryo without allow-listing
```

```go
// Go - gob/encoding from untrusted source
gob.NewDecoder(untrustedReader).Decode(&obj)
// encoding/xml with external entities
```

**Detection regex**:
```regex
(?i)(pickle\.load|pickle\.loads|yaml\.load|marshal\.load)\s*\(
(?i)(ObjectInputStream|XMLDecoder|XStream)\s*\(
(?i)(eval|Function)\s*\(\s*(req|request|user|input|body|params|data)
(?i)node-serialize
```

**Unsigned or unverified updates/artifacts**:
```regex
# Downloading scripts/binaries and executing without verification
(?i)curl\s+.*\|\s*(sh|bash)
(?i)wget\s+.*&&\s*(sh|bash|chmod\s+\+x)
# Missing: checksum verification, signature validation
```

**CI/CD integrity**:
```regex
# Unpinned GitHub Actions
uses:\s+[^@]+@(main|master|latest)
# Should be: uses: action/name@SHA-or-tag

# Unpinned Docker base images
FROM\s+\w+:latest
FROM\s+\w+\s*$    # No tag at all
```

### Severity: **CRITICAL** (deserialization of untrusted data, unverified code execution) / **HIGH** (unpinned dependencies in CI/CD)

### Recommended Fix
- Never deserialize untrusted data with `pickle`, `ObjectInputStream`, or `eval`.
- Use `yaml.safe_load()` instead of `yaml.load()`.
- Verify checksums and signatures on all downloaded artifacts.
- Pin CI/CD actions to specific commit SHAs.
- Pin Docker base images to digest or specific version tags.

---

## A09: Security Logging and Monitoring Failures

Insufficient logging of security events, missing audit trails, unmonitored systems.

### Code Patterns to Detect

**Missing authentication event logging**:
```regex
# Login/logout/failed auth handlers without log statements
(?i)def\s+(login|logout|authenticate|sign_in|sign_out|failed_login)
# Verify: logger.info/warn/audit call present in the function body
```

**Missing authorization failure logging**:
```regex
# 403/401 responses without corresponding log entries
(?i)(403|401|Forbidden|Unauthorized)
# Check surrounding code for logging
```

**Sensitive data in logs**:
```regex
(?i)(log|logger|logging|console)\.\w+\(.*\b(password|passwd|token|secret|ssn|credit.?card|pan)\b
```

**Missing error logging**:
```regex
# Bare exception handlers
except\s*:
except\s+Exception\s*:
catch\s*\(.*\)\s*\{\s*\}       # Empty catch block
catch\s*\(.*\)\s*\{\s*//       # Catch with only a comment
```

**Log injection vulnerability**:
```regex
# User input directly in log format string
(?i)(log|logger)\.\w+\(.*\b(req|request|user_input|params)\b
# Verify: is input sanitized for newlines/control characters?
```

### Severity: **HIGH** (missing auth logging) / **MEDIUM** (missing error logging) / **HIGH** (sensitive data in logs)

### Recommended Fix
- Log all authentication events: success, failure, lockout, MFA.
- Log all authorization failures with request context (who, what, when).
- Sanitize log inputs to prevent log injection (strip newlines, control characters).
- Never log sensitive data (passwords, tokens, PII).
- Implement structured logging with consistent fields.
- Ensure logs are forwarded to a centralized monitoring system.

---

## A10: Server-Side Request Forgery (SSRF)

Application fetches resources from user-supplied URLs without proper validation.

### Code Patterns to Detect

**Direct URL fetching from user input**:
```python
# Python
import requests
url = request.args.get('url')
response = requests.get(url)

import urllib.request
urllib.request.urlopen(request.form['callback'])
```

```javascript
// Node.js
const url = req.body.url;
const response = await fetch(url);
// or
axios.get(req.query.imageUrl);
http.get(req.body.webhook);
```

```go
// Go
url := r.FormValue("url")
resp, err := http.Get(url)
```

```java
// Java
String url = request.getParameter("url");
URL obj = new URL(url);
HttpURLConnection conn = (HttpURLConnection) obj.openConnection();
```

**Detection regex**:
```regex
(?i)(requests\.(get|post|put|head)|urllib\.request\.urlopen|fetch|axios\.(get|post)|http\.Get|HttpClient)\s*\(.*\b(req|request|params|body|query|form|args)\b
```

**Partial mitigations to verify**:
```regex
# URL allowlist check (good but verify completeness)
(?i)(allowed_hosts|allowlist|whitelist|valid_urls)

# IP range blocking (check for bypass via DNS rebinding, redirects, IPv6)
(?i)(is_private|is_internal|blocked_ips|deny_list)

# Protocol restriction (should block file://, gopher://, dict://)
(?i)(https?://|allowed_schemes|valid_protocols)
```

### Severity: **HIGH** to **CRITICAL** (depending on internal network exposure)

### Recommended Fix
- Validate and allowlist target domains/IPs.
- Block requests to internal/private IP ranges (`10.0.0.0/8`, `172.16.0.0/12`,
  `192.168.0.0/16`, `127.0.0.0/8`, `169.254.0.0/16`, `::1`, `fc00::/7`).
- Block non-HTTP(S) protocols (`file://`, `gopher://`, `dict://`, `ftp://`).
- Disable HTTP redirects or validate each redirect target.
- Use a dedicated egress proxy for outbound requests.
- Consider DNS resolution validation to prevent DNS rebinding.

---

## Review Procedure Summary

When performing vulnerability pattern detection:

1. **Map the attack surface**: identify all entry points (HTTP endpoints, CLI
   arguments, file inputs, message consumers, IPC).
2. **Trace data flow**: follow user-controlled input from entry points through
   processing logic to sinks (database, OS, file system, network, output).
3. **Check each OWASP category** against the patterns above.
4. **Assess severity** based on exploitability, data exposure, and blast radius.
5. **Verify mitigations**: if a pattern is detected, check for corresponding
   sanitization, validation, or authorization logic before classifying as a finding.
6. **Document the data flow** in each finding: source (where input enters) to sink
   (where damage occurs), including any intermediate transformations.
